<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `strided` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, strided">

    <title>strided - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'strided', ty: 'mod', relpath: '../'};</script>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>strided</a><wbr></span><span class='out-of-band'><a href='stability.html'>[stability]</a> <span id='render-detail'>
            <a id="collapse-all" href="#">[-]</a>&nbsp;<a id="expand-all" href="#">[+]</a>
        </span><a id='src-0' href='../src/strided/lib.rs.html#1-288'>[src]</a></span></h1>
<div class='docblock'><p>Strided slices.</p>

<p>This library provides two types <code>Stride</code> and <code>MutStride</code> as
generalised forms of <code>&amp;[T]</code> and <code>&amp;mut [T]</code> respectively, where the
elements are regularly spaced in memory, but not necessarily
immediately adjacently.</p>

<p>For example, given an underlying array <code>[1, 2, 3, 4, 5]</code>, the
elements <code>[1, 3, 5]</code> are a strided slice with stride 2, and
<code>[1, 4]</code> has stride 3. Any slice can be regarded as a strided slice
with stride 1.</p>

<p>This provides functionality through which one can safely and
efficiently manipulate every <code>n</code>th element of a slice (even a
mutable one) as close as possible to it being a conventional
slice. This releases one from worries about stride bookkeeping,
aliasing of <code>&amp;mut</code> or any <code>unsafe</code> code.</p>

<h1 id="quick-start" class='section-header'><a
                           href="#quick-start">Quick start</a></h1>
<p>The work-horse functions are <code>.substrides(n)</code> and
<code>.substrides_mut(n)</code>, which return an iterator across a series of
<code>n</code> new strided slices (shared and mutable, respectively), each of
which points to every <code>n</code>th element, and each of which starts at
the next successive offset. For example, the following has
<code>n = 3</code>.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>strided</span>::<span class='ident'>MutStride</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>1u8</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>all</span> <span class='op'>=</span> <span class='ident'>MutStride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>v</span>);

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>substrides</span> <span class='op'>=</span> <span class='ident'>all</span>.<span class='ident'>substrides_mut</span>(<span class='number'>3</span>);

<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>substrides</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>substrides</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>substrides</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>substrides</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>()); <span class='comment'>// there was exactly 3.</span>

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>, <span class='ident'>MutStride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>1</span>, <span class='number'>4</span>]));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>b</span>, <span class='ident'>MutStride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>2</span>, <span class='number'>5</span>]));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>c</span>, <span class='ident'>MutStride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>3</span>]));
</pre>

<p>The common case of <code>n = 2</code> has an abbreviation <code>substrides2</code>
(resp. <code>substrides2_mut</code>), which takes the liberty of returns a
tuple rather than an iterator to make direct destructuring
work. Continuing with the values above, <code>left</code> and <code>right</code> point
to alternate elements, starting at index <code>0</code> and <code>1</code> of their
parent slice respectively.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> (<span class='ident'>left</span>, <span class='ident'>right</span>) <span class='op'>=</span> <span class='ident'>all</span>.<span class='ident'>substrides2_mut</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>left</span>, <span class='ident'>MutStride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>1</span>, <span class='number'>3</span>, <span class='number'>5</span>]));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>right</span>, <span class='ident'>MutStride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>2</span>, <span class='number'>4</span>]));
</pre>

<p>A lot of the conventional slice functionality is available, such
as indexing, iterators and slicing.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> (<span class='kw-2'>mut</span> <span class='ident'>left</span>, <span class='ident'>right</span>) <span class='op'>=</span> <span class='ident'>all</span>.<span class='ident'>substrides2_mut</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>left</span>[<span class='number'>2</span>], <span class='number'>5</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>right</span>.<span class='ident'>get</span>(<span class='number'>10</span>).<span class='ident'>is_none</span>()); <span class='comment'>// out of bounds</span>

<span class='ident'>left</span>[<span class='number'>2</span>] <span class='op'>+=</span> <span class='number'>10</span>;
<span class='kw'>match</span> <span class='ident'>left</span>.<span class='ident'>get_mut</span>(<span class='number'>0</span>) {
    <span class='prelude-val'>Some</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='op'>*</span><span class='ident'>val</span> <span class='op'>-=</span> <span class='number'>1</span>,
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> {}
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>right</span>.<span class='ident'>iter</span>().<span class='ident'>fold</span>(<span class='number'>0</span>, <span class='op'>|</span><span class='ident'>sum</span>, <span class='ident'>a</span><span class='op'>|</span> <span class='ident'>sum</span> <span class='op'>+</span> <span class='op'>*</span><span class='ident'>a</span>), <span class='number'>2</span> <span class='op'>+</span> <span class='number'>4</span>);
<span class='kw'>for</span> <span class='ident'>val</span> <span class='kw'>in</span> <span class='ident'>left</span>.<span class='ident'>iter_mut</span>() {
    <span class='op'>*</span><span class='ident'>val</span> <span class='op'>/=</span> <span class='number'>2</span>
}
</pre>

<h2 id="ownership-and-reborrow" class='section-header'><a
                           href="#ownership-and-reborrow">Ownership and <code>reborrow</code></a></h2>
<p><code>MutStride</code> has a method <code>reborrow</code> which has signature</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>MutStride</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>reborrow</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>MutStride</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span>, <span class='ident'>T</span><span class='op'>&gt;</span> { ... }
}
</pre>

<p>That is, it allows temporarily viewing a strided slices as one
with a shorter lifetime. This method is key because many of the
methods on <code>MutStride</code> take <code>self</code> by-value and so consume
ownership... which is rather unfortunate if one wants to use a
strided slice multiple times.</p>

<p>The temporary returned by <code>reborrow</code> can be used with the
consuming methods, which allows the parent slice to continuing
being used after that temporary has disappeared. For example, all
of the splitting and slicing methods on <code>MutStride</code> consume
ownership, and so <code>reborrow</code> is necessary there to continue using,
in this case, <code>left</code>.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> (<span class='kw-2'>mut</span> <span class='ident'>left</span>, <span class='ident'>right</span>) <span class='op'>=</span> <span class='ident'>all</span>.<span class='ident'>substrides2_mut</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>left</span>.<span class='ident'>reborrow</span>().<span class='ident'>slice_mut</span>(<span class='number'>1</span>, <span class='number'>3</span>), <span class='ident'>MutStride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>3</span>, <span class='number'>5</span>]));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>left</span>.<span class='ident'>reborrow</span>().<span class='ident'>slice_from_mut</span>(<span class='number'>2</span>), <span class='ident'>MutStride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>5</span>]));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>left</span>.<span class='ident'>reborrow</span>().<span class='ident'>slice_to_mut</span>(<span class='number'>2</span>), <span class='ident'>MutStride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>1</span>, <span class='number'>3</span>]));

<span class='comment'>// no reborrow:</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>right</span>.<span class='ident'>split_at_mut</span>(<span class='number'>1</span>),
           (<span class='ident'>MutStride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>2</span>]), <span class='ident'>MutStride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>4</span>])));
<span class='comment'>// println!(&quot;{}&quot;, right); // error: use of moved value `right`.</span>
</pre>

<p>These contortions are necessary to ensure that <code>&amp;mut</code>s cannot
alias, while still maintaining flexibility: leaving elements with
the maximum possible lifetime (i.e. that of the non-strided slices
which they lie in). Theoretically they are necessary with
<code>&amp;mut []</code> too, but the compiler inserts implicit reborrows and so
one rarely needs to do them manually.</p>

<p>In practice, one should only need to insert <code>reborrow</code>s if the
compiler complains about the use of a moved value.</p>

<p>The shared <code>Stride</code> is equivalent to <code>&amp;[]</code> and only handles <code>&amp;</code>
references, making ownership transfer and <code>reborrow</code> unnecessary,
so all its methods act identically to those on <code>&amp;[]</code>.</p>

<h1 id="example" class='section-header'><a
                           href="#example">Example</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform">fast Fourier transform
(FFT)</a> is a
signal processing algorithm that performs a discrete Fourier
transform (DFT) of length <code>n</code> in <code>O(n log n)</code> time. A DFT breaks a
waveform into the sum of sines and cosines, and is an important
part of many other algorithms due to certain nice properties of
the Fourier transform.</p>

<p>The first FFT algorithm was the <a href="https://en.wikipedia.org/wiki/Cooley-Tukey_FFT_algorithm">Cooley-Tukey
algorithm</a>. The
decimation-in-time variant works by computing the FFT of
equal-length subarrays of equally spaced elements and then
combining these together into the desired result. This sort of
spacing is exactly the striding provided by this library, and
hence this library can be used to create an FFT algorithm in a
very natural way.</p>

<p>Below is an implementation of the radix-2 case, that is, when the
length <code>n</code> is a power of two. In this case, only two strided
subarrays are necessary: exactly the alternating ones provided by
<code>substrides2</code>. Note the use of <code>reborrow</code> to allow <code>start</code> and
<code>end</code> to be used for the recursive <code>fft</code> calls and then again
later in the loop.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>strided</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>num</span>; <span class='comment'>// https://github.com/rust-lang/num</span>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>;
<span class='kw'>use</span> <span class='ident'>num</span>::<span class='ident'>complex</span>::{<span class='ident'>Complex</span>, <span class='ident'>Complex64</span>};
<span class='kw'>use</span> <span class='ident'>strided</span>::{<span class='ident'>MutStride</span>, <span class='ident'>Stride</span>};

<span class='doccomment'>/// Writes the forward DFT of `input` to `output`.</span>
<span class='kw'>fn</span> <span class='ident'>fft</span>(<span class='ident'>input</span>: <span class='ident'>Stride</span><span class='op'>&lt;</span><span class='ident'>Complex64</span><span class='op'>&gt;</span>, <span class='kw-2'>mut</span> <span class='ident'>output</span>: <span class='ident'>MutStride</span><span class='op'>&lt;</span><span class='ident'>Complex64</span><span class='op'>&gt;</span>) {
    <span class='comment'>// check it&#39;s a power of two.</span>
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>input</span>.<span class='ident'>len</span>() <span class='op'>==</span> <span class='ident'>output</span>.<span class='ident'>len</span>() <span class='op'>&amp;&amp;</span> <span class='ident'>input</span>.<span class='ident'>len</span>().<span class='ident'>count_ones</span>() <span class='op'>==</span> <span class='number'>1</span>);

    <span class='comment'>// base case: the DFT of a single element is itself.</span>
    <span class='kw'>if</span> <span class='ident'>input</span>.<span class='ident'>len</span>() <span class='op'>==</span> <span class='number'>1</span> {
        <span class='ident'>output</span>[<span class='number'>0</span>] <span class='op'>=</span> <span class='ident'>input</span>[<span class='number'>0</span>];
        <span class='kw'>return</span>
    }

    <span class='comment'>// split the input into two arrays of alternating elements (&quot;decimate in time&quot;)</span>
    <span class='kw'>let</span> (<span class='ident'>evens</span>, <span class='ident'>odds</span>) <span class='op'>=</span> <span class='ident'>input</span>.<span class='ident'>substrides2</span>();
    <span class='comment'>// break the output into two halves (front and back, not alternating)</span>
    <span class='kw'>let</span> (<span class='kw-2'>mut</span> <span class='ident'>start</span>, <span class='kw-2'>mut</span> <span class='ident'>end</span>) <span class='op'>=</span> <span class='ident'>output</span>.<span class='ident'>split_at_mut</span>(<span class='ident'>input</span>.<span class='ident'>len</span>() <span class='op'>/</span> <span class='number'>2</span>);

    <span class='comment'>// recursively perform two FFTs on alternating elements of the input, writing the</span>
    <span class='comment'>// results into the first and second half of the output array respectively.</span>
    <span class='ident'>fft</span>(<span class='ident'>evens</span>, <span class='ident'>start</span>.<span class='ident'>reborrow</span>());
    <span class='ident'>fft</span>(<span class='ident'>odds</span>, <span class='ident'>end</span>.<span class='ident'>reborrow</span>());

    <span class='comment'>// exp(-2πi/N)</span>
    <span class='kw'>let</span> <span class='ident'>twiddle</span> <span class='op'>=</span> <span class='ident'>Complex</span>::<span class='ident'>from_polar</span>(<span class='kw-2'>&amp;</span><span class='number'>1.0</span>, <span class='kw-2'>&amp;</span>(<span class='op'>-</span><span class='number'>2.0</span> <span class='op'>*</span> <span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span> <span class='op'>/</span> <span class='ident'>input</span>.<span class='ident'>len</span>() <span class='kw'>as</span> <span class='ident'>f64</span>));

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>factor</span> <span class='op'>=</span> <span class='ident'>Complex</span>::<span class='ident'>new</span>(<span class='number'>1.</span>, <span class='number'>0.</span>);

    <span class='comment'>// combine the subFFTs with the relations:</span>
    <span class='comment'>//   X_k       = E_k + exp(-2πki/N) * O_k</span>
    <span class='comment'>//   X_{k+N/2} = E_k - exp(-2πki/N) * O_k</span>
    <span class='kw'>for</span> (<span class='ident'>even</span>, <span class='ident'>odd</span>) <span class='kw'>in</span> <span class='ident'>start</span>.<span class='ident'>iter_mut</span>().<span class='ident'>zip</span>(<span class='ident'>end</span>.<span class='ident'>iter_mut</span>()) {
        <span class='kw'>let</span> <span class='ident'>twiddled</span> <span class='op'>=</span> <span class='ident'>factor</span> <span class='op'>*</span> <span class='op'>*</span><span class='ident'>odd</span>;
        <span class='kw'>let</span> <span class='ident'>e</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>even</span>;

        <span class='op'>*</span><span class='ident'>even</span> <span class='op'>=</span> <span class='ident'>e</span> <span class='op'>+</span> <span class='ident'>twiddled</span>;
        <span class='op'>*</span><span class='ident'>odd</span> <span class='op'>=</span> <span class='ident'>e</span> <span class='op'>-</span> <span class='ident'>twiddled</span>;
        <span class='ident'>factor</span> <span class='op'>=</span> <span class='ident'>factor</span> <span class='op'>*</span> <span class='ident'>twiddle</span>;
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='ident'>Complex</span>::<span class='ident'>new</span>(<span class='number'>2.</span>, <span class='number'>0.</span>), <span class='ident'>Complex</span>::<span class='ident'>new</span>(<span class='number'>1.</span>, <span class='number'>0.</span>),
             <span class='ident'>Complex</span>::<span class='ident'>new</span>(<span class='number'>2.</span>, <span class='number'>0.</span>), <span class='ident'>Complex</span>::<span class='ident'>new</span>(<span class='number'>1.</span>, <span class='number'>0.</span>)];
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>b</span> <span class='op'>=</span> [<span class='ident'>Complex</span>::<span class='ident'>new</span>(<span class='number'>0.</span>, <span class='number'>0.</span>); <span class='number'>4</span>];

    <span class='ident'>fft</span>(<span class='ident'>Stride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='ident'>a</span>), <span class='ident'>MutStride</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>b</span>));
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;forward: {:?} -&gt; {:?}&quot;</span>, <span class='kw-2'>&amp;</span><span class='ident'>a</span>, <span class='kw-2'>&amp;</span><span class='ident'>b</span>);
}
</pre>

<p>The above definitely has complexity <code>O(n log n)</code>, but it has a
much larger constant factor than an optimised library like
<a href="http://www.fftw.org/">FFTW</a>. (Strictly speaking <code>output</code> does not
need to be a strided slice, since it is never split into
alternating elements.)</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='struct' href='struct.Items.html'
                               title='strided::Items'>Items</a></td>
                        <td class='docblock short'><p>An iterator over shared references to the elements of a strided
slice.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='struct' href='struct.MutItems.html'
                               title='strided::MutItems'>MutItems</a></td>
                        <td class='docblock short'><p>An iterator over mutable references to the elements of a strided
slice.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='struct' href='struct.MutStride.html'
                               title='strided::MutStride'>MutStride</a></td>
                        <td class='docblock short'><p>A mutable strided slice. This is equivalent to <code>&amp;mut [T]</code>, that
only refers to every <code>n</code>th <code>T</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='struct' href='struct.MutSubstrides.html'
                               title='strided::MutSubstrides'>MutSubstrides</a></td>
                        <td class='docblock short'><p>An iterator over <code>n</code> mutable substrides of a given stride, each of
which points to every <code>n</code>th element starting at successive
offsets.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='struct' href='struct.Stride.html'
                               title='strided::Stride'>Stride</a></td>
                        <td class='docblock short'><p>A shared strided slice. This is equivalent to a <code>&amp;[T]</code> that only
refers to every <code>n</code>th <code>T</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='struct' href='struct.Substrides.html'
                               title='strided::Substrides'>Substrides</a></td>
                        <td class='docblock short'><p>An iterator over <code>n</code> shared substrides of a given stride, each of
which points to every <code>n</code>th element starting at successive
offsets.</p>
</td>
                    </tr>
                </table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='trait' href='trait.MutStrided.html'
                               title='strided::MutStrided'>MutStrided</a></td>
                        <td class='docblock short'><p>Things that can be viewed as a series of mutable equally spaced
<code>T</code>s in memory.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='trait' href='trait.Strided.html'
                               title='strided::Strided'>Strided</a></td>
                        <td class='docblock short'><p>Things that can be viewed as a series of equally spaced <code>T</code>s in
memory.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "strided";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>